---
title: 指针笔记
description: 指针用法及注意事项笔记
categories:
- C++
tags:
- C++
---

### 指针优点：
1. 为函数提供修改调用变元的手段；
2. 支持C++动态分配子程序
3. 可以改善某些子程序的效率
4. 为动态数据结构（如二叉树、链表）提供支持
> 注：指针为程序引入了一层间接性，可以操控指针而不直接操控对象。
5. 可操控指针内含的地址也可操控指针所指的对象
6. 指针可能并不指向任何对象，写`*pi`时，可能会使程序在执行期错误，如寻址到某个
对象，则提领操作，不指向任何对象,会出错，所以在提领前先确定它的确指向某对象


一个未指向任何对象的指针，内含地址为0,有时称为null指针,assert (p != 0)可检测是否分配成功。也可用if (pi),只有在pi含非零值时，才为true.

## 定义：
为存放内存地址的变量。
诠释：
指针为一数据类型也有自己的地址。占用四个字节的存储空间
int * p:　&p返回的是指针p的地址,而不是所指变量的地址
地址：一般指内存中另一变量的位置

## 指针变量：
type * name 声明时必须确保它的类型与要指向的对象类型兼容
const 是“最靠近”为原则
指向整数常量的指针：const int * p;它所指向的值只读不能被修改 `*p = 4`(错误),p = 5(正确)
指向一个整数的常量指针：int * const p;不允许修改指针变量的值，`*p = 5` (正确),
p = 5 (错误)

## 指针操作符：
&（取址运算符）：一元操作符，只作用于一个操作数，返回操作数的地址
`*`（提领操作）:一元操作符，是&的补操作，返回其操作数所指变量的值

## 指针赋值及转换：
同类型直接赋值，异类型要进行转换。
强制转换：可以把表达式结果硬性转换为指定类型
`char * p;(int *)p` 把p强制转换为int型，记住转换过程中要注意两个类型的大小，大
转小时可能会有数据丢失（如int到double）
涉及`void *`的:
c 中`void *`类型可赋值给任何类型的指针，反之亦然
c++ 中都需要强制转换
`void *`可似为无穷大能接纳任何类型赋值，反之不行int * p =9;void * t= p（正确）;p=t(错误)
不涉及`void *`的都要强制转换

## 指针的算术操作
和整数的加法，减法，自身的增量、减量
指针增量后指向下一个与指针基类同型的元素，增减单位是所指类型的长度。

## 其他说明：
1. 指针和数组：
不带下标的数组名返回数组的起始地址，即数组首元素的地址，所以对数组的访问可有
两种方式：数组下标和指针算术
2. 函数指针：
函数具有可赋给指针的物理内存地址，一个函数地址也为该函数的进入点，也是调用函
数的地址
3. 多级指针地址　`**p`

## 动态内存分配
定义：是程序在运行中取得内存的方法。是从堆（heap）--系统的自由内存区－取得内存
运算符：
new(c中的malloc):自动建立一个具有合适大小的对象，返回具有正确类型的指针，如分配不成功，返回一个空指针0，且可自动调用构造函数。
> char * p = new char('t');
delete(c中的free):delect p;
释放数组对象时要使用方括号delete [] p;

## 与引用的区别
＆引用运算符：
1. 引用只是变量的别名，而不是指向变量的指针(区别于取址运算符"&")不占内存空间
，对变量引用的改变其相应的变量也会改变。
2. 不能对引用使用指针间接运算符“*”进行复引用操作
3. 引用必须在声明时初始化　int &c = count;(c是count的别名)

## 注意：
在每次使用指针前，都应该初始化。以防止指针指向空对象。
应用举例(pointer.cpp)
编译环境：Windows 7 Vc6.0

```cpp
#include <iostream>
using namespace std;

void main()
{
  //int * p =1, 不对，整型常量不能转换为整型指针，char * t =0 可以
  //指针运算符&返回操作数的地址，此处&p,&q是p,q的地址
  //要返回得到指向的地址要么正接用p,q 要么用&(*p),&(*q),指针也是
  //是一种数据类型也有自己的内存地址为4个字节，8位
  int * q , * p;
  int x =1 ,y = 2;

  q = &x;
  p = &y;
  cout << "p" << &p << " " << &(*p) << " " << p << " " << *p << endl;
  cout << "q" << &q << " " << &(*q) << " " << q << " " << *q << endl;

  //指针赋值,整个指针包含的地址、指向的对象都改变了
  int * t;
  t = q;
  q = p;
  p = t;
  cout << "p" << p << " "<< *p << endl;
  cout << "q" << q << " " << *q << endl;

  //指针所指对象的赋值操作,地址不变
  q = &x; //1
  p = &y; //2
  cout << "p" << p << " "<< *p << endl;
  cout << "q" << q << " " << *q << endl;

  //强制类型转换
  //double *l;
  //l = (double*)*q; // q的值赋给临时变量 *t=1
  *t = *q; // q的值赋给临时变量 *t=1
  cout << *t <<endl;
  *q = *p; // q的值给q,*q=2
  cout << *q <<endl;

  *p = *t;
  cout << *t <<endl;
  cout << "p" << p << " "<< *p << endl;
  cout << "q" << q << " " << *q << endl;

  //引用的使用
  int count = 1;
  int &c = count; //声明c为count的引用，c只是count的别名，不占实际内存空间
  cout << "引用";
  cout << c << count << endl;

  //引用变量在声明时要初始化
  //int &t; (错误)
  //t = count ;
  //不能用指针间接运算符复引用一引用，引用只是一变量的别名
  //它不占地址空间
  //cout << *c << endl;

  int iF = 10;
  const int * ciS = 0; //指向整数常量的指针,指针最好都进行初始化
  int * iT = &iF;

  //*ciS = 100;(错误),*ciS为常量
  ciS = iT;
  cout << ciS << " "<< *ciS <<endl;

  int * const icS = &iF; //指向整数的常量指针
  *icS = 10;
  icS = iT;
  cout << icS << " " << *icS << endl;
}
```